schema {
  query: Query
  mutation: Mutation
}

type Account implements Node {
  id: ID!
  code: String!
  name: String!
  beginningBal: Float!
  operations(after: String, first: Int, before: String, last: Int): AccountOperationsConnection
}

type AccountOperationsConnection {
  pageInfo: PageInfo!
  edges: [AccountOperationsEdge]
  totalCount: Int
}

type AccountOperationsEdge {
  node: Operation
  cursor: String!
}

input AddBillInput {
  sessionToken: String!
  id: String
  companyId: ID!
  props: AddBillProps
  clientMutationId: String!
}

type AddBillPayload {
  billEdge: CompanyBillsEdge
  changedPaymentsIds: [String!]!
  payee: Vendor
  company: Company
  viewer: User
  clientMutationId: String!
}

input AddBillProps {
  payee: ParseObjectInputFieldType
  mailingAddress: String!
  terms: PaymentTerm!
  items: [BillItemInputType!]!
  date: DateTime!
  dueDate: DateTime!
  paymentRef: String
  memo: String
  files: [String!]
}

input AddCompanyInput {
  sessionToken: String!
  id: ID
  displayName: String!
  periodType: Period!
  clientMutationId: String!
}

type AddCompanyPayload {
  companyEdge: UserCompaniesEdge
  viewer: User
  clientMutationId: String!
}

input AddCustomerInput {
  id: String
  sessionToken: String!
  companyId: ID!
  fieldInfos: [FieldValueType!]!
  clientMutationId: String!
}

type AddCustomerPayload {
  customerEdge: CompanyCustomersEdge
  viewer: User
  company: Company
  clientMutationId: String!
}

input AddEmployeeInput {
  id: String
  sessionToken: String!
  companyId: ID!
  fieldInfos: [FieldValueType!]!
  clientMutationId: String!
}

type AddEmployeePayload {
  employeeEdge: CompanyEmployeesEdge
  viewer: User
  company: Company
  clientMutationId: String!
}

input AddExpenseInput {
  sessionToken: String!
  id: String
  companyId: ID!
  props: AddExpenseProps
  clientMutationId: String!
}

type AddExpensePayload {
  expenseEdge: CompanyExpensesEdge
  customer: Customer
  vendor: Vendor
  company: Company
  clientMutationId: String!
}

input AddExpenseProps {
  payee: ParseTypedObjectInputFieldType0!
  creditToAccountCode: String!
  date: DateTime!
  paymentMethod: PaymentMethod!
  items: [ExpenseItemInputType!]!
  paymentRef: String
  memo: String
  files: [String!]
}

input AddInvoiceInput {
  sessionToken: String!
  id: String
  companyId: ID!
  props: AddInvoiceProps
  clientMutationId: String!
}

type AddInvoicePayload {
  invoiceEdge: CompanyInvoicesEdge
  changedPaymentsIds: [String!]!
  customer: Customer
  company: Company
  viewer: User
  clientMutationId: String!
}

input AddInvoiceProps {
  customer: ParseObjectInputFieldType
  billingAddress: String!
  terms: PaymentTerm!
  items: [InvoiceItemInputType!]!
  date: DateTime!
  dueDate: DateTime!
  discountType: DiscountValue!
  discountValue: Float = 0.0
  memo: String
  files: [String!]
}

input AddProductInput {
  sessionToken: String!
  id: String
  companyId: ID!
  fieldInfos: [FieldValueType!]!
  clientMutationId: String!
}

type AddProductPayload {
  productEdge: CompanyProductsEdge
  company: Company
  clientMutationId: String!
}

input AddSaleInput {
  sessionToken: String!
  companyId: ID!
  id: String
  props: AddSaleProps
  clientMutationId: String!
}

type AddSalePayload {
  saleEdge: CompanySalesEdge
  customer: Customer
  company: Company
  clientMutationId: String!
}

input AddSaleProps {
  customer: ParseObjectInputFieldType
  billingAddress: String!
  date: DateTime!
  paymentMethod: PaymentMethod!
  depositToAccountCode: String!
  items: [SaleItemInputType!]!
  discountType: DiscountValue!
  discountValue: Float = 0.0
  memo: String
  files: [String!]
}

input AddVendorInput {
  id: String
  sessionToken: String!
  companyId: ID!
  fieldInfos: [FieldValueType!]!
  clientMutationId: String!
}

type AddVendorPayload {
  vendorEdge: CompanyVendorsEdge
  viewer: User
  company: Company
  clientMutationId: String!
}

type Bank implements Node {
  id: ID!
  displayName: String!
  icon: String!
  accountCode: String!
}

type Bill implements Node {
  id: ID!
  paymentRef: String
  payee: Vendor
  mailingAddress: String!
  terms: PaymentTerm!
  date: DateTime!
  dueDate: DateTime!
  itemsConnection: BillItemsConnection
  paymentsConnection: BillPaymentsConnection
  _balanceDue: Float!
  _total: Float!
  _totalReceived: Float!
  _status: TransactionStatus!
  memo: String
  files: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

type BillItem implements Node {
  id: ID!
  index: Int!
  accountCode: String!
  description: String
  amount: Float!
  createdAt: DateTime!
  objectId: String!
  className: String!
}

input BillItemInputType {
  index: Int!
  accountCode: String
  description: String
  amount: Float!
}

type BillItemsConnection {
  pageInfo: PageInfo!
  edges: [BillItemsEdge]
  totalCount: Int
  totalAmount: Float
}

type BillItemsEdge {
  node: BillItem
  cursor: String!
}

type BillPaymentsConnection {
  pageInfo: PageInfo!
  edges: [BillPaymentsEdge]
  totalCount: Int
  totalAmountPaid: Float
  latestPayment: PaymentOfBillsItem
}

type BillPaymentsEdge {
  node: PaymentOfBillsItem
  cursor: String!
}

type ChartAccount {
  id: ID!
  code: String!
  name: String!
  _classCode: String!
  _categoryCode: String!
  _groupCode: String!
  _parentCode: String
}

type Company implements Node {
  id: ID!
  address: String
  activity: String
  webSite: String
  tel: String
  fax: String
  email: String
  if: String
  rc: String
  patente: String
  cnss: String
  banque: String
  rib: String
  legalForm: LegalForm
  periodType: Period!
  displayName: String!
  lastTransactionIndex: Int!
  lastPaymentsTransactionIndex: Int!
  operationsByCategories(after: String, first: Int, before: String, last: Int, type: OperationKind, from: DateTime, to: DateTime, categories: [String!], _rev: Int): CompanyOperationsByCategoriesConnection
  employees(after: String, first: Int, before: String, last: Int): CompanyEmployeesConnection
  customers(after: String, first: Int, before: String, last: Int): CompanyCustomersConnection
  vendors(after: String, first: Int, before: String, last: Int): CompanyVendorsConnection
  people(after: String, first: Int, before: String, last: Int): CompanyPeopleConnection
  sales(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanySalesConnection
  expenses(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyExpensesConnection
  paymentsOfInvoices(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyPaymentsOfInvoicesConnection
  paymentsOfBills(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyPaymentsOfBillsConnection
  invoices(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyInvoicesConnection
  bills(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyBillsConnection
  transactions(after: String, first: Int, before: String, last: Int): CompanyTransactionsConnection
  accounts(after: String, first: Int, before: String, last: Int): CompanyAccountsConnection
  bankAccounts(after: String, first: Int, before: String, last: Int): CompanyBankAccountsConnection
  settings: CompanySettingsType
  salesSettings: CompanySaleSettings!
  expensesSettings: CompanyExpenseSettings!
  paymentsSettings: CompanyPaymentSettings!
  companyProducts(after: String, first: Int, before: String, last: Int): CompanyProductsConnection
  salesStatus: SalesStatus
  expensesStatus: ExpensesStatus
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

type CompanyAccountsConnection {
  pageInfo: PageInfo!
  edges: [CompanyAccountsEdge]
  totalCount: Int
}

type CompanyAccountsEdge {
  node: Account
  cursor: String!
}

type CompanyBankAccountsConnection {
  pageInfo: PageInfo!
  edges: [CompanyBankAccountsEdge]
  totalCount: Int
}

type CompanyBankAccountsEdge {
  node: Bank
  cursor: String!
}

type CompanyBillsConnection {
  pageInfo: PageInfo!
  edges: [CompanyBillsEdge]
  totalCount: Int
  sumOfTotals: Float
  sumOfBalances: Float
}

type CompanyBillsEdge {
  node: Bill
  cursor: String!
}

type CompanyCustomersConnection {
  pageInfo: PageInfo!
  edges: [CompanyCustomersEdge]
  totalCount: Int
}

type CompanyCustomersEdge {
  node: Customer
  cursor: String!
}

type CompanyCustomersInvoicesQueryConnection {
  pageInfo: PageInfo!
  edges: [CompanyCustomersInvoicesQueryEdge]
  totalCount: Int
}

type CompanyCustomersInvoicesQueryEdge {
  node: Customer
  cursor: String!
}

type CompanyCustomersPaymentsOfInvoicesQueryConnection {
  pageInfo: PageInfo!
  edges: [CompanyCustomersPaymentsOfInvoicesQueryEdge]
  totalCount: Int
}

type CompanyCustomersPaymentsOfInvoicesQueryEdge {
  node: Customer
  cursor: String!
}

type CompanyCustomersQuery {
  invoices(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyCustomersInvoicesQueryConnection
  sales(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyCustomersSalesQueryConnection
  payments(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyCustomersPaymentsOfInvoicesQueryConnection
}

type CompanyCustomersSalesQueryConnection {
  pageInfo: PageInfo!
  edges: [CompanyCustomersSalesQueryEdge]
  totalCount: Int
}

type CompanyCustomersSalesQueryEdge {
  node: Customer
  cursor: String!
}

type CompanyEmployeesConnection {
  pageInfo: PageInfo!
  edges: [CompanyEmployeesEdge]
  totalCount: Int
}

type CompanyEmployeesEdge {
  node: Employee
  cursor: String!
}

type CompanyExpensesConnection {
  pageInfo: PageInfo!
  edges: [CompanyExpensesEdge]
  totalCount: Int
  sumOfTotals: Float
}

type CompanyExpensesEdge {
  node: Expense
  cursor: String!
}

type CompanyExpenseSettings {
  defaultExpenseAccountCode: String!
  preferredPaymentMethod: PaymentMethod!
}

input CompanyExpenseSettingsInputType {
  defaultExpenseAccountCode: String
  preferredPaymentMethod: PaymentMethod
}

type CompanyExpensesStatusBills_ClosedConnection {
  pageInfo: PageInfo!
  edges: [CompanyExpensesStatusBills_ClosedEdge]
  totalCount: Int!
  amount: Float!
}

type CompanyExpensesStatusBills_ClosedEdge {
  node: SaleOrPaymentOfBillsBridge
  cursor: String!
}

type CompanyExpensesStatusBills_OpenConnection {
  pageInfo: PageInfo!
  edges: [CompanyExpensesStatusBills_OpenEdge]
  totalCount: Int!
  amount: Float!
}

type CompanyExpensesStatusBills_OpenEdge {
  node: Bill
  cursor: String!
}

type CompanyExpensesStatusBills_OverdueConnection {
  pageInfo: PageInfo!
  edges: [CompanyExpensesStatusBills_OverdueEdge]
  totalCount: Int!
  amount: Float!
}

type CompanyExpensesStatusBills_OverdueEdge {
  node: Bill
  cursor: String!
}

type CompanyInvoicesConnection {
  pageInfo: PageInfo!
  edges: [CompanyInvoicesEdge]
  totalCount: Int
  sumOfTotals: Float
  sumOfBalances: Float
}

type CompanyInvoicesEdge {
  node: Invoice
  cursor: String!
}

type CompanyOperationsByCategoriesConnection {
  pageInfo: PageInfo!
  edges: [CompanyOperationsByCategoriesEdge]
}

type CompanyOperationsByCategoriesEdge {
  node: Operation
  cursor: String!
}

type CompanyPaymentSettings {
  defaultDepositToAccountCode: String!
  preferredPaymentMethod: PaymentMethod!
}

input CompanyPaymentSettingsInputType {
  defaultDepositToAccountCode: String
  preferredPaymentMethod: PaymentMethod
}

type CompanyPaymentsOfBillsConnection {
  pageInfo: PageInfo!
  edges: [CompanyPaymentsOfBillsEdge]
  totalCount: Int
  sumOfTotals: Float
  sumOfCredits: Float
}

type CompanyPaymentsOfBillsEdge {
  node: PaymentOfBills
  cursor: String!
}

type CompanyPaymentsOfInvoicesConnection {
  pageInfo: PageInfo!
  edges: [CompanyPaymentsOfInvoicesEdge]
  totalCount: Int
  sumOfTotals: Float
  sumOfCredits: Float
}

type CompanyPaymentsOfInvoicesEdge {
  node: PaymentOfInvoices
  cursor: String!
}

type CompanyPeopleConnection {
  pageInfo: PageInfo!
  edges: [CompanyPeopleEdge]
  totalCount: Int
}

type CompanyPeopleEdge {
  node: Person
  cursor: String!
}

type CompanyProductsConnection {
  pageInfo: PageInfo!
  edges: [CompanyProductsEdge]
  totalCount: Int
}

type CompanyProductsEdge {
  node: Product
  cursor: String!
}

type CompanySalesConnection {
  pageInfo: PageInfo!
  edges: [CompanySalesEdge]
  totalCount: Int
  sumOfTotals: Float
}

type CompanySalesEdge {
  node: Sale
  cursor: String!
}

type CompanySaleSettings {
  discountEnabled: Boolean!
  defaultDepositToAccountCode: String!
  preferredInvoiceTerms: PaymentTerm!
  enableCustomTransactionNumbers: Boolean!
  enableServiceDate: Boolean!
  showProducts: Boolean!
  showRates: Boolean!
  trackInventory: Boolean!
  defaultIncomeAccountCode: String!
}

input CompanySaleSettingsInputType {
  discountEnabled: Boolean
  defaultDepositToAccountCode: String
  preferredInvoiceTerms: PaymentTerm
  enableCustomTransactionNumbers: Boolean
  enableServiceDate: Boolean
  showProducts: Boolean
  showRates: Boolean
  trackInventory: Boolean
  defaultIncomeAccountCode: String
}

type CompanySalesStatusInvoices_ClosedConnection {
  pageInfo: PageInfo!
  edges: [CompanySalesStatusInvoices_ClosedEdge]
  totalCount: Int!
  amount: Float!
}

type CompanySalesStatusInvoices_ClosedEdge {
  node: SaleOrPaymentOfInvoicesBridge
  cursor: String!
}

type CompanySalesStatusInvoices_OpenConnection {
  pageInfo: PageInfo!
  edges: [CompanySalesStatusInvoices_OpenEdge]
  totalCount: Int!
  amount: Float!
}

type CompanySalesStatusInvoices_OpenEdge {
  node: Invoice
  cursor: String!
}

type CompanySalesStatusInvoices_OverdueConnection {
  pageInfo: PageInfo!
  edges: [CompanySalesStatusInvoices_OverdueEdge]
  totalCount: Int!
  amount: Float!
}

type CompanySalesStatusInvoices_OverdueEdge {
  node: Invoice
  cursor: String!
}

input CompanySettingsInputType {
  periodType: Period
  closureEnabled: Boolean
  closureDate: DateTime
}

type CompanySettingsType {
  periodType: Period!
  closureEnabled: Boolean!
  closureDate: DateTime
}

type CompanyTransactionsConnection {
  pageInfo: PageInfo!
  edges: [CompanyTransactionsEdge]
  totalCount: Int
}

type CompanyTransactionsEdge {
  node: Transaction
  cursor: String!
}

type CompanyVendorsBillsQueryConnection {
  pageInfo: PageInfo!
  edges: [CompanyVendorsBillsQueryEdge]
  totalCount: Int
}

type CompanyVendorsBillsQueryEdge {
  node: Vendor
  cursor: String!
}

type CompanyVendorsConnection {
  pageInfo: PageInfo!
  edges: [CompanyVendorsEdge]
  totalCount: Int
}

type CompanyVendorsEdge {
  node: Vendor
  cursor: String!
}

type CompanyVendorsExpensesQueryConnection {
  pageInfo: PageInfo!
  edges: [CompanyVendorsExpensesQueryEdge]
  totalCount: Int
}

type CompanyVendorsExpensesQueryEdge {
  node: Vendor
  cursor: String!
}

type CompanyVendorsPaymentsOfBillsQueryConnection {
  pageInfo: PageInfo!
  edges: [CompanyVendorsPaymentsOfBillsQueryEdge]
  totalCount: Int
}

type CompanyVendorsPaymentsOfBillsQueryEdge {
  node: Vendor
  cursor: String!
}

type CompanyVendorsQuery {
  bills(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyVendorsBillsQueryConnection
  expenses(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyVendorsExpensesQueryConnection
  payments(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CompanyVendorsPaymentsOfBillsQueryConnection
}

type Customer implements Node, Person {
  id: ID!
  displayName: String!
  image: String
  title: String
  givenName: String
  middleName: String
  familyName: String
  affiliation: String
  emails: String
  phone: String
  mobile: String
  fax: String
  website: String
  billing_streetAddress: String
  billing_cityTown: String
  billing_stateProvince: String
  billing_postalCode: String
  billing_country: String
  notes: String
  openBalance: Float!
  sales(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CustomerSalesConnection
  paymentsOfInvoices(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CustomerPaymentsOfInvoicesConnection
  invoices(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): CustomerInvoicesConnection
  salesStatus: CustomerSalesStatus
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
}

type CustomerInvoicesConnection {
  pageInfo: PageInfo!
  edges: [CustomerInvoicesEdge]
  totalCount: Int
  sumOfTotals: Float
  sumOfBalances: Float
}

type CustomerInvoicesEdge {
  node: Invoice
  cursor: String!
}

type CustomerOpenBillsConnection {
  pageInfo: PageInfo!
  edges: [CustomerOpenBillsEdge]
}

type CustomerOpenBillsEdge {
  node: Bill
  cursor: String!
}

type CustomerOpenInvoicesConnection {
  pageInfo: PageInfo!
  edges: [CustomerOpenInvoicesEdge]
}

type CustomerOpenInvoicesEdge {
  node: Invoice
  cursor: String!
}

type CustomerPaymentsOfInvoicesConnection {
  pageInfo: PageInfo!
  edges: [CustomerPaymentsOfInvoicesEdge]
  totalCount: Int
  sumOfTotals: Float
  sumOfCredits: Float
}

type CustomerPaymentsOfInvoicesEdge {
  node: PaymentOfInvoices
  cursor: String!
}

type CustomerSalesConnection {
  pageInfo: PageInfo!
  edges: [CustomerSalesEdge]
  totalCount: Int
  sumOfTotals: Float
}

type CustomerSalesEdge {
  node: Sale
  cursor: String!
}

type CustomerSalesStatus {
  open: CustomerSalesStatusInvoices_OpenConnection
  overdue: CustomerSalesStatusInvoices_OverdueConnection
}

type CustomerSalesStatusInvoices_OpenConnection {
  pageInfo: PageInfo!
  edges: [CustomerSalesStatusInvoices_OpenEdge]
  totalCount: Int!
  amount: Float!
}

type CustomerSalesStatusInvoices_OpenEdge {
  node: Invoice
  cursor: String!
}

type CustomerSalesStatusInvoices_OverdueConnection {
  pageInfo: PageInfo!
  edges: [CustomerSalesStatusInvoices_OverdueEdge]
  totalCount: Int!
  amount: Float!
}

type CustomerSalesStatusInvoices_OverdueEdge {
  node: Invoice
  cursor: String!
}

scalar DateTime

type DiscountPart {
  type: DiscountValue
  value: Float
}

input DiscountPartInput {
  type: DiscountValue
  value: Float
}

enum DiscountValue {
  Value
  Percent
}

type Employee implements Node, Person {
  id: ID!
  displayName: String!
  image: String
  title: String
  givenName: String
  middleName: String
  familyName: String
  affiliation: String
  emails: String
  phone: String
  mobile: String
  fax: String
  website: String
  address_streetAddress: String
  address_cityTown: String
  address_stateProvince: String
  address_postalCode: String
  address_country: String
  notes: String
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
}

type Expense implements Node, ExpenseOrPaymentOfBills {
  id: ID!
  payee: Person
  creditToAccountCode: String!
  date: DateTime!
  paymentMethod: PaymentMethod!
  paymentRef: String
  itemsConnection: expenseItemTypeItemsConnection
  memo: String
  files: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

type ExpenseItem implements Node {
  id: ID!
  index: Int!
  accountCode: String!
  description: String
  amount: Float!
  createdAt: DateTime!
  objectId: String!
  className: String!
}

input ExpenseItemInputType {
  index: Int!
  accountCode: String!
  description: String
  amount: Float!
}

type expenseItemTypeItemsConnection {
  pageInfo: PageInfo!
  edges: [expenseItemTypeItemsEdge]
  totalCount: Int
  amountPaid: Float
}

type expenseItemTypeItemsEdge {
  node: ExpenseItem
  cursor: String!
}

interface ExpenseOrPaymentOfBills {
  id: ID!
  payee: Person
  date: DateTime!
  memo: String
  files: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
}

type ExpensesStatus {
  open: CompanyExpensesStatusBills_OpenConnection
  overdue: CompanyExpensesStatusBills_OverdueConnection
  closed: CompanyExpensesStatusBills_ClosedConnection
}

input FieldValueType {
  fieldName: String!
  value: String
}

type Invoice implements Node {
  id: ID!
  refNo: Int!
  customer: Customer
  billingAddress: String!
  terms: PaymentTerm!
  date: DateTime!
  dueDate: DateTime!
  discountType: DiscountValue!
  discountValue: Float
  itemsConnection: InvoiceItemsConnection
  paymentsConnection: InvoicePaymentsConnection
  _balanceDue: Float!
  _total: Float!
  _totalReceived: Float!
  _status: TransactionStatus!
  memo: String
  files: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

type InvoiceItem implements Node {
  id: ID!
  index: Int!
  date: DateTime
  item: Product
  description: String
  qty: Int!
  rate: Float!
  discountPart: DiscountPart
  createdAt: DateTime!
  objectId: String!
  className: String!
}

input InvoiceItemInputType {
  index: Int!
  date: DateTime
  item: InvoiceItemLineInputType
  description: String
  qty: Int!
  rate: Float!
  discountPart: DiscountPartInput
}

input InvoiceItemLineInputType {
  className: String!
  id: String!
  incomeAccountCode: String
}

type InvoiceItemsConnection {
  pageInfo: PageInfo!
  edges: [InvoiceItemsEdge]
  totalCount: Int
  totalAmount: Float
}

type InvoiceItemsEdge {
  node: InvoiceItem
  cursor: String!
}

type InvoicePaymentsConnection {
  pageInfo: PageInfo!
  edges: [InvoicePaymentsEdge]
  totalCount: Int
  totalAmountReceived: Float
  latestPayment: PaymentOfInvoicesItem
}

type InvoicePaymentsEdge {
  node: PaymentOfInvoicesItem
  cursor: String!
}

enum LegalForm {
  SARL
  SA
  SNC
  SARL_AU
}

input LogInInput {
  email: String!
  password: String
  clientMutationId: String!
}

type LogInPayload {
  viewer: User
  clientMutationId: String!
}

input LogOutInput {
  viewerId: ID!
  clientMutationId: String!
}

type LogOutPayload {
  viewer: User
  clientMutationId: String!
}

type Mutation {
  addCompany(input: AddCompanyInput!): AddCompanyPayload
  updateCompany(input: UpdateCompanyInput!): UpdateCompanyPayload
  updateCompanySettings(input: UpdateCompanySettingsInput!): UpdateCompanySettingsPayload
  updateCompanySalesSettings(input: UpdateCompanySalesSettingsInput!): UpdateCompanySalesSettingsPayload
  updateCompanyExpensesSettings(input: UpdateCompanyExpensesSettingsInput!): UpdateCompanyExpensesSettingsPayload
  updateCompanyPaymentsSettings(input: UpdateCompanyPaymentsSettingsInput!): UpdateCompanyPaymentsSettingsPayload
  removeCompany(input: RemoveCompanyInput!): RemoveCompanyPayload
  updateCustomerNotes(input: UpdateCustomerNotesInput!): UpdateCustomerNotesPayload
  updateVendorNotes(input: UpdateVendorNotesInput!): UpdateVendorNotesPayload
  addProduct(input: AddProductInput!): AddProductPayload
  delProduct(input: RemoveProductInput!): RemoveProductPayload
  addBill(input: AddBillInput!): AddBillPayload
  addInvoice(input: AddInvoiceInput!): AddInvoicePayload
  addSale(input: AddSaleInput!): AddSalePayload
  addExpense(input: AddExpenseInput!): AddExpensePayload
  receivePaymentOfInvoices(input: ReceivePaymentOfInvoicesInput!): ReceivePaymentOfInvoicesPayload
  receivePaymentOfBills(input: ReceivePaymentOfBillsInput!): ReceivePaymentOfBillsPayload
  removeInvoice(input: RemoveInvoiceInput!): RemoveInvoicePayload
  removeBill(input: RemoveBillInput!): RemoveBillPayload
  removeSale(input: RemoveSaleInput!): RemoveSalePayload
  removeExpense(input: RemoveExpenseInput!): RemoveExpensePayload
  removePaymentOfInvoices(input: RemovePaymentOfInvoicesInput!): RemovePaymentOfInvoicesPayload
  removePaymentOfBills(input: RemovePaymentOfBillsInput!): RemovePaymentOfBillsPayload
  addEmployee(input: AddEmployeeInput!): AddEmployeePayload
  removeEmployee(input: RemoveEmployeeInput!): RemoveEmployeePayload
  addCustomer(input: AddCustomerInput!): AddCustomerPayload
  removeCustomer(input: RemoveCustomerInput!): RemoveCustomerPayload
  addVendor(input: AddVendorInput!): AddVendorPayload
  removeVendor(input: RemoveVendorInput!): RemoveVendorPayload
  logIn(input: LogInInput!): LogInPayload
  logOut(input: LogOutInput!): LogOutPayload
}

interface Node {
  id: ID!
}

type Operation implements Node {
  id: ID!
  refNo: Int
  isAdjustment: Boolean!
  accountCode: String!
  type: OperationKind!
  amount: Float!
  date: DateTime!
  memo: String
  _classCode: String!
  _categoryCode: String!
  _groupCode: String!
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

enum OperationKind {
  DEBIT
  CREDIT
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

input ParseObjectInputFieldType {
  className: String!
  id: String!
}

input ParseTypedObjectInputFieldType0 {
  type: ParseTypedObjectInputFieldTypeEnum0!
  className: String!
  id: String!
}

enum ParseTypedObjectInputFieldTypeEnum0 {
  Customer
  Vendor
}

enum PaymentMethod {
  Cash
  Check
  Creditcard
}

type PaymentOfBills implements Node, ExpenseOrPaymentOfBills {
  id: ID!
  payee: Vendor
  date: DateTime!
  mailingAddress: String!
  paymentRef: String
  refNo: String!
  creditToAccountCode: String!
  itemsConnection: PaymentOfBillsItemsConnection
  amountReceived: Float!
  _amountToApply: Float!
  _amountToCredit: Float!
  memo: String
  files: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

type PaymentOfBillsItem implements Node {
  id: ID!
  index: Int!
  date: DateTime!
  amount: Float!
  payment: PaymentOfBills!
  bill: Bill!
  createdAt: DateTime!
  objectId: String!
  className: String!
}

input PaymentOfBillsItemInputType {
  index: Int!
  billId: String!
  amount: Float!
}

type PaymentOfBillsItemsConnection {
  pageInfo: PageInfo!
  edges: [PaymentOfBillsItemsEdge]
  totalCount: Int
  totalAmountPaid: Float
}

type PaymentOfBillsItemsEdge {
  node: PaymentOfBillsItem
  cursor: String!
}

type PaymentOfInvoices implements Node, SaleOrPaymentOfInvoices {
  id: ID!
  customer: Customer
  date: DateTime!
  paymentMethod: PaymentMethod!
  paymentRef: String
  depositToAccountCode: String!
  itemsConnection: PaymentOfInvoicesItemsConnection
  amountReceived: Float!
  _amountToApply: Float!
  _amountToCredit: Float!
  memo: String
  files: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

type PaymentOfInvoicesItem implements Node {
  id: ID!
  index: Int!
  date: DateTime!
  amount: Float!
  payment: PaymentOfInvoices!
  invoice: Invoice!
  createdAt: DateTime!
  objectId: String!
  className: String!
}

input PaymentOfInvoicesItemInputType {
  index: Int!
  invoiceId: String!
  amount: Float!
}

type PaymentOfInvoicesItemsConnection {
  pageInfo: PageInfo!
  edges: [PaymentOfInvoicesItemsEdge]
  totalCount: Int
  totalAmountReceived: Float
}

type PaymentOfInvoicesItemsEdge {
  node: PaymentOfInvoicesItem
  cursor: String!
}

enum PaymentTerm {
  OnReception
  Net_15
  Net_30
  Net_60
  Custom
}

enum Period {
  MONTHLY
  TRIMESTERLY
}

interface Person {
  id: ID!
  displayName: String!
  image: String
  title: String
  givenName: String
  middleName: String
  familyName: String
  affiliation: String
  emails: String
  phone: String
  mobile: String
  fax: String
  website: String
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
}

type Product implements Node {
  id: ID!
  type: ProductKind!
  displayName: String!
  image: String
  sku: String
  salesDesc: String
  salesPrice: Float
  incomeAccountCode: String
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

enum ProductKind {
  Product
  Service
}

type Query {
  node(id: ID!): Node
  viewer: User
}

input ReceivePaymentOfBillsInput {
  sessionToken: String!
  companyId: ID!
  id: String
  props: ReceivePaymentOfBillsProps
  clientMutationId: String!
}

type ReceivePaymentOfBillsPayload {
  paymentEdge: CompanyPaymentsOfBillsEdge
  changedBillsIds: [String!]!
  viewer: User
  payee: Vendor
  company: Company
  clientMutationId: String!
}

input ReceivePaymentOfBillsProps {
  payee: ParseObjectInputFieldType
  date: DateTime!
  mailingAddress: String!
  paymentRef: String
  creditToAccountCode: String!
  amountReceived: Float!
  items: [PaymentOfBillsItemInputType!]!
  memo: String
  files: [String!]
}

input ReceivePaymentOfInvoicesInput {
  sessionToken: String!
  companyId: ID!
  id: String
  props: ReceivePaymentOfInvoicesProps
  clientMutationId: String!
}

type ReceivePaymentOfInvoicesPayload {
  paymentEdge: CompanyPaymentsOfInvoicesEdge
  changedInvoicesIds: [String!]!
  viewer: User
  customer: Customer
  company: Company
  clientMutationId: String!
}

input ReceivePaymentOfInvoicesProps {
  customer: ParseObjectInputFieldType
  date: DateTime!
  paymentMethod: PaymentMethod!
  paymentRef: String
  depositToAccountCode: String!
  amountReceived: Float!
  items: [PaymentOfInvoicesItemInputType!]!
  memo: String
  files: [String!]
}

input RemoveBillInput {
  sessionToken: String!
  id: String!
  companyId: ID!
  clientMutationId: String!
}

type RemoveBillPayload {
  deletedBillId: ID
  company: Company
  clientMutationId: String!
}

input RemoveCompanyInput {
  sessionToken: String!
  id: ID!
  clientMutationId: String!
}

type RemoveCompanyPayload {
  deletedCompanyId: ID
  viewer: User
  clientMutationId: String!
}

input RemoveCustomerInput {
  sessionToken: String!
  id: ID!
  companyId: ID!
  clientMutationId: String!
}

type RemoveCustomerPayload {
  deletedCustomerId: ID
  company: Company
  clientMutationId: String!
}

input RemoveEmployeeInput {
  sessionToken: String!
  id: ID!
  companyId: ID!
  clientMutationId: String!
}

type RemoveEmployeePayload {
  deletedEmployeeId: ID
  company: Company
  clientMutationId: String!
}

input RemoveExpenseInput {
  sessionToken: String!
  id: String!
  companyId: ID!
  clientMutationId: String!
}

type RemoveExpensePayload {
  deletedExpenseId: ID
  company: Company
  clientMutationId: String!
}

input RemoveInvoiceInput {
  sessionToken: String!
  id: String!
  companyId: ID!
  clientMutationId: String!
}

type RemoveInvoicePayload {
  deletedInvoiceId: ID
  company: Company
  clientMutationId: String!
}

input RemovePaymentOfBillsInput {
  sessionToken: String!
  id: String!
  companyId: ID!
  clientMutationId: String!
}

type RemovePaymentOfBillsPayload {
  deletedPaymentId: ID
  company: Company
  clientMutationId: String!
}

input RemovePaymentOfInvoicesInput {
  sessionToken: String!
  id: String!
  companyId: ID!
  clientMutationId: String!
}

type RemovePaymentOfInvoicesPayload {
  deletedPaymentId: ID
  company: Company
  clientMutationId: String!
}

input RemoveProductInput {
  sessionToken: String!
  id: ID!
  companyId: ID!
  clientMutationId: String!
}

type RemoveProductPayload {
  deletedProductId: ID
  company: Company
  clientMutationId: String!
}

input RemoveSaleInput {
  sessionToken: String!
  id: String!
  companyId: ID!
  clientMutationId: String!
}

type RemoveSalePayload {
  deletedSaleId: ID
  company: Company
  clientMutationId: String!
}

input RemoveVendorInput {
  sessionToken: String!
  id: ID!
  companyId: ID!
  clientMutationId: String!
}

type RemoveVendorPayload {
  deletedVendorId: ID
  company: Company
  clientMutationId: String!
}

type Sale implements Node, SaleOrPaymentOfInvoices {
  id: ID!
  customer: Customer
  billingAddress: String!
  date: DateTime!
  paymentMethod: PaymentMethod!
  paymentRef: String
  refNo: Int!
  depositToAccountCode: String!
  discountType: DiscountValue!
  discountValue: Float
  itemsConnection: SaleItemsConnection
  _balanceDue: Float!
  _total: Float!
  memo: String
  files: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

type SaleItem implements Node {
  id: ID!
  index: Int!
  item: Product!
  date: DateTime
  description: String
  qty: Int!
  rate: Float!
  discountPart: DiscountPart
  createdAt: DateTime!
  objectId: String!
  className: String!
}

input SaleItemInputType {
  index: Int!
  date: DateTime
  item: SaleItemLineInputType
  description: String
  qty: Int!
  rate: Float!
  discountPart: DiscountPartInput
}

input SaleItemLineInputType {
  className: String!
  id: String!
}

type SaleItemsConnection {
  pageInfo: PageInfo!
  edges: [SaleItemsEdge]
  totalCount: Int
  amountReceived: Float
}

type SaleItemsEdge {
  node: SaleItem
  cursor: String!
}

type SaleOrPaymentOfBillsBridge {
  value: ExpenseOrPaymentOfBills!
}

interface SaleOrPaymentOfInvoices {
  id: ID!
  customer: Customer
  date: DateTime!
  memo: String
  files: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
}

type SaleOrPaymentOfInvoicesBridge {
  value: SaleOrPaymentOfInvoices!
}

type SalesStatus {
  open: CompanySalesStatusInvoices_OpenConnection
  overdue: CompanySalesStatusInvoices_OverdueConnection
  closed: CompanySalesStatusInvoices_ClosedConnection
}

type Transaction implements Node {
  id: ID!
  operations(after: String, first: Int, before: String, last: Int): TransactionOperationsConnection
  refNo: Int
  isAdjustment: Boolean!
  date: DateTime!
  memo: String
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
  user: User
}

type TransactionOperationsConnection {
  pageInfo: PageInfo!
  edges: [TransactionOperationsEdge]
  totalCount: Int
}

type TransactionOperationsEdge {
  node: Operation
  cursor: String!
}

enum TransactionStatus {
  Open
  Closed
  Overdue
}

input UpdateCompanyExpensesSettingsInput {
  sessionToken: String!
  id: ID!
  settings: CompanyExpenseSettingsInputType!
  clientMutationId: String!
}

type UpdateCompanyExpensesSettingsPayload {
  company: Company
  clientMutationId: String!
}

input UpdateCompanyInput {
  sessionToken: String!
  id: ID!
  fieldInfos: [FieldValueType!]!
  clientMutationId: String!
}

type UpdateCompanyPayload {
  company: Company
  clientMutationId: String!
}

input UpdateCompanyPaymentsSettingsInput {
  sessionToken: String!
  id: ID!
  settings: CompanyPaymentSettingsInputType!
  clientMutationId: String!
}

type UpdateCompanyPaymentsSettingsPayload {
  company: Company
  clientMutationId: String!
}

input UpdateCompanySalesSettingsInput {
  sessionToken: String!
  id: ID!
  settings: CompanySaleSettingsInputType!
  clientMutationId: String!
}

type UpdateCompanySalesSettingsPayload {
  company: Company
  clientMutationId: String!
}

input UpdateCompanySettingsInput {
  sessionToken: String!
  id: ID!
  settings: CompanySettingsInputType!
  clientMutationId: String!
}

type UpdateCompanySettingsPayload {
  company: Company
  clientMutationId: String!
}

input UpdateCustomerNotesInput {
  sessionToken: String!
  companyId: ID!
  id: String!
  notes: String
  clientMutationId: String!
}

type UpdateCustomerNotesPayload {
  customer: Customer
  clientMutationId: String!
}

input UpdateVendorNotesInput {
  sessionToken: String!
  companyId: ID!
  id: String!
  notes: String
  clientMutationId: String!
}

type UpdateVendorNotesPayload {
  vendor: Vendor
  clientMutationId: String!
}

type User implements Node {
  id: ID!
  displayName: String
  email: String
  username: String
  sessionToken: String
  company(id: ID!): Company!
  getTransaction(companyId: String!, id: String!): Transaction
  getTransactionByType(companyId: String!, type: String!, id: String!): Transaction
  customerOpenInvoices(after: String, first: Int, before: String, last: Int, companyId: ID!, id: String): CustomerOpenInvoicesConnection
  vendorOpenBills(after: String, first: Int, before: String, last: Int, companyId: ID!, id: String): CustomerOpenBillsConnection
  companies(after: String, first: Int, before: String, last: Int): UserCompaniesConnection
  accounts: [ChartAccount]
  accountsByCategories(categories: [String!]!): [ChartAccount!]!
  paymentOfInvoicesFromPaymentOfInvoicesItem(companyId: String!, id: String!): PaymentOfInvoices!
  paymentOfBillsFromPaymentOfBillsItem(companyId: String!, id: String!): PaymentOfBills!
  getCustomer(companyId: String!, id: String!): Customer
  getCustomers(companyId: String!): CompanyCustomersQuery
  getVendor(companyId: String!, id: String!): Vendor
  getVendors(companyId: String!): CompanyVendorsQuery
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
}

type UserCompaniesConnection {
  pageInfo: PageInfo!
  edges: [UserCompaniesEdge]
  totalCount: Int
}

type UserCompaniesEdge {
  node: Company
  cursor: String!
}

type Vendor implements Node, Person {
  id: ID!
  displayName: String!
  image: String
  title: String
  givenName: String
  middleName: String
  familyName: String
  affiliation: String
  emails: String
  phone: String
  mobile: String
  fax: String
  website: String
  mailing_streetAddress: String
  mailing_cityTown: String
  mailing_stateProvince: String
  mailing_postalCode: String
  mailing_country: String
  notes: String
  openBalance: Float!
  expenses(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): VendorExpensesConnection
  paymentsOfBills(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): VendorPaymentsOfBillsConnection
  bills(after: String, first: Int, before: String, last: Int, type: String, status: String, offset: Int, limit: Int, from: DateTime, to: DateTime, sortKey: String, sortDir: Int, customer: String, payee: String, _rev: Int): VendorBillsConnection
  expensesStatus: VendorExpensesStatus
  createdAt: DateTime!
  updatedAt: DateTime
  objectId: String!
  className: String!
}

type VendorBillsConnection {
  pageInfo: PageInfo!
  edges: [VendorBillsEdge]
  totalCount: Int
  sumOfTotals: Float
  sumOfBalances: Float
}

type VendorBillsEdge {
  node: Bill
  cursor: String!
}

type VendorExpensesConnection {
  pageInfo: PageInfo!
  edges: [VendorExpensesEdge]
  totalCount: Int
  sumOfTotals: Float
}

type VendorExpensesEdge {
  node: Expense
  cursor: String!
}

type VendorExpensesStatus {
  open: VendorExpensesStatusBills_OpenConnection
  overdue: VendorExpensesStatusBills_OverdueConnection
}

type VendorExpensesStatusBills_OpenConnection {
  pageInfo: PageInfo!
  edges: [VendorExpensesStatusBills_OpenEdge]
  totalCount: Int!
  amount: Float!
}

type VendorExpensesStatusBills_OpenEdge {
  node: Bill
  cursor: String!
}

type VendorExpensesStatusBills_OverdueConnection {
  pageInfo: PageInfo!
  edges: [VendorExpensesStatusBills_OverdueEdge]
  totalCount: Int!
  amount: Float!
}

type VendorExpensesStatusBills_OverdueEdge {
  node: Bill
  cursor: String!
}

type VendorPaymentsOfBillsConnection {
  pageInfo: PageInfo!
  edges: [VendorPaymentsOfBillsEdge]
  totalCount: Int
  sumOfTotals: Float
  sumOfCredits: Float
}

type VendorPaymentsOfBillsEdge {
  node: PaymentOfBills
  cursor: String!
}
